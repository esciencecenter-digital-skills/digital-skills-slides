[{"_path":"/modules/good-practices-lesson","_dir":"modules","_draft":false,"_partial":false,"_locale":"","title":"Good Practices in Research Software Engineering","description":"Photo by OCG Saving The Ocean on Unsplash","id":2,"category":"Good Practices","author":"eScience Center","thumbnail":"good-practices-thumbnail.png","visibility":"visible","_type":"markdown","_id":"local_fs:modules:good-practices-lesson:index.md","_source":"local_fs","_file":"modules/good-practices-lesson/index.md","_extension":"md","plainText":"---\nid: 2\ncategory: Good Practices\ntitle: Good Practices in Research Software Engineering\nauthor: eScience Center\nthumbnail: \"good-practices-thumbnail.png\"\nvisibility: visible\n---\n\nPhoto by <a href=\"https://unsplash.com/@oceancleanupgroup?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">OCG Saving The Ocean</a> on <a href=\"https://unsplash.com/photos/man-in-blue-t-shirt-and-blue-shorts-playing-soccer-on-beach-during-daytime-psRG_u3DLps?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Unsplash</a>\n  \n"},{"_path":"/modules/good-practices-lesson/modular-code-slides","_dir":"good-practices-lesson","_draft":false,"_partial":false,"_locale":"","title":"Modular Code","description":"Day 3 Code Refinery","type":"slides","order":2,"author":"Barbara Vreede, Ole Mussmann","_type":"markdown","_id":"local_fs:modules:good-practices-lesson:modular-code-slides.md","_source":"local_fs","_file":"modules/good-practices-lesson/modular-code-slides.md","_extension":"md","plainText":"---\ntitle: Modular Code\ntype: slides\norder: 2\nauthor: Barbara Vreede, Ole Mussmann\ndescription: Day 3 Code Refinery\n---\n\n<!-- .slide: data-state=\"title\" -->\n\n# Developing Modular Code\n\nnote: \n\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## What is modularity?\n\n- Software is 'built up' from smaller elements\n- Elements are self-contained and independent\n- Each element handles a specific (set of) task(s)\n\n**Simple components** build **complex behavior**.\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## Modular code\n\n<img width=\"900\" alt=\"think in building blocks\" src=\"https://user-images.githubusercontent.com/5747405/207459058-59c88b4c-1401-428f-b28a-0ac3e72bd964.png\">\n\n===\n\n<!-- .slide: data-state=\"standard\" -->\n\n## What are these blocks/elements?\n\n- functions\n- classes\n- modules\n- libraries/packages\n- programs\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Why write modular code?\n\nTo increase robustness:\n\n<img width=\"200\" alt=\"testing a single module\" src=\"./media/modular-code/testing_module.png\">\n\n- A well-designed module can be tested.\n- This helps keep the codebase well-functioning and bug-free.\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Why write modular code?\n\nTo make maintenance easier:\n\n<img width=\"300\" alt=\"testing a module taken from a larger project\" src=\"./media/modular-code/testing_module_maintenance.png\">\n\n- Modular code is more readable and understandable.\n- Modules can be debugged separately.\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Why write modular code?\n\nTo allow reusability:\n\n<img width=\"400\" alt=\"reuse a module in another project\" src=\"./media/modular-code/reuse_module.png\">\n\n- A module can live independent of its original context\n- It can be reused by another project\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Why write modular code?\n\nTo facilitate scalability:\n\n<img height=\"300\" alt=\"scalability\" src=\"./media/modular-code/scalability.png\">\n\n\n<div>\n\n- Complexity remains low by design\n- This creates space for scaling up\n\n</div>\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Why write modular code?\n\nTo create opportunities for innovation:\n\n<img height=\"300\" alt=\"tetris shows innovation\" src=\"./media/modular-code/tetris_innovation.png\">\n\n- Modules increase the capabilities and power of a project\n- Rearrange old modules for new applications\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n<img width=\"800\" alt=\"development speed\" src=\"./media/modular-code/development-speed.svg\">\n\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## A good module...\n\n- performs limited and clearly defined tasks\n- has a good name\n<!-- .element: class=\"fragment\" data-fragment-index=\"2\" -->\n- is readable\n<!-- .element: class=\"fragment\" data-fragment-index=\"3\" -->\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Readability =/= shorter code\n\nShorter:\n```python=\nindexATG = [n for n,i in enumerate(myList) if i == 'ATG']\nindexAAG = [n for n,i in enumerate(myList) if i == 'AAG']\n```\n\nMore modular:\n```python=\ndef getIndex(inputList,z):\n    zIndex = [n for n,i in enumerate(li) if i == z]\n    return zIndex\n\nindexATG = getIndex(myList,'ATG')\nindexAAG = getIndex(myList,'AAG')\n```\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## A good module...\n\n- performs limited and clearly defined tasks\n- has a good name\n- is readable\n- is pure/does not have a 'state'\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## A pure function\n\nhas no side-effects:\n\n```python=\ndef fahrenheit_to_celsius(temp_f):\n    temp_c = (temp_f - 32.0) * (5.0/9.0)\n    return temp_c\n\n>>> temp_c = fahrenheit_to_celsius(temp_f=77.0)\n>>> print(temp_c)\n25.0\n```\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## A stateful function\n\nchanges its environment:\n\n```python=\ndef fahrenheit_to_celsius(temp_f):\n    global temp_c\n    temp_c = (temp_f - f_to_c_offset) * f_to_c_factor\n\n>>> f_to_c_offset = 32.0\n>>> f_to_c_factor = (5.0/9.0)\n>>> temp_c = 0.0\n>>> print(temp_c)\n0.0\n>>> fahrenheit_to_celsius(temp_f=77.0)\n>>> print(temp_c)\n25.0\n```\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Identifying opportunities for modularization\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Focus on readability\n\n- Modular code becomes more readable\n- Code is read more than it is written\n- Does a reader understand what the code does?\n- Bad readability can be a \"code smell\"\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Identify future functions\n\n- Don't Repeat Yourself (DRY): place reused code into a function\n- Identify potential functions by their _action_\n    (e.g. \"plotting\", \"transforming\", \"extracting\", \"saving\")\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Target nested code\n\nNested code is a prime target for modularization:\n\n```python=\ndef checkTemperature(degrees):\n    if degrees < 0:\n        if degrees < -273:\n            if degrees < -459:\n                print(\"This temperature is impossible.\")\n            else:\n                print(\"This temperature is likely Fahrenheit.\")\n        else:\n            print(\"This temperature is either Celsius or Fahrenheit.\")\n    else:\n        print(\"This temperature is in Kelvin, Celsius, or Fahrhenheit.\")\n```\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Reduce nestedness\n\nby extracting modules:\n\n```python=\ndef validTemp(degrees):\n    if degrees < -459:\n        return FALSE\n    return TRUE\n\ndef checkTemperature(degrees):\n    if not validTemp(degrees):\n        return \"invalid temperature\"\n    if degrees < 0:\n        if degrees < -273:\n            print(\"This temperature is likely Fahrenheit.\")\n        else:\n            print(\"This temperature is either Celsius or Fahrenheit.\")\n    else:\n        print(\"This temperature is in Kelvin, Celsius, or Fahrhenheit.\")\n```\n\n===\n\n<!-- .slide: data-state=\"standard\"  -->\n\n## Let tests help you\n\n- Write tests for each individual module\n- Use the test-writing procedure to look critically at the module's function:\n    - Is the input/output clear?\n    - What can you not yet test? Extract it into a new module.\n\n"}]